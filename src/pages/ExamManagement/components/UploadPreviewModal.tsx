import { Modal, Card, Button, Typography, Space } from 'antd';
import { useState, useCallback } from 'react';
import { EyeOutlined, EditOutlined, CheckCircleOutlined } from '@ant-design/icons';

const { Title, Paragraph, Text } = Typography;

interface UploadedQuestion {
  question: string;
  answers: string;
}

interface UploadPreviewModalProps {
  visible: boolean;
  data: UploadedQuestion[];
  onClose: () => void;
  onConfirm: (data: any) => void;
}

const UploadPreviewModal = ({ visible, data, onClose, onConfirm }: UploadPreviewModalProps) => {
  const [selectedQuestions, setSelectedQuestions] = useState<number[]>([]);

  // Safeguard: ƒê·∫£m b·∫£o data l√† array h·ª£p l·ªá
  const safeData = Array.isArray(data) ? data : [];

  // Parse answers from string to array of 4 options
  const parseAnswers = useCallback((answersString: string): string[] => {
    if (!answersString || typeof answersString !== 'string') return ['', '', '', ''];
    
    // T√°ch c√°c ƒë√°p √°n A, B, C, D t·ª´ chu·ªói
    // V√≠ d·ª•: "A. nh√† ·ªü.\nB. vi·ªác l√†m.\nC. t√†i s·∫£n.\nD. nh√¢n th√¢n."
    const lines = answersString.split('\n');
    const options = ['', '', '', ''];
    
    lines.forEach(line => {
      const match = line.match(/^([A-D])\. (.+)$/);
      if (match) {
        const index = match[1].charCodeAt(0) - 65; // A=0, B=1, C=2, D=3
        if (index >= 0 && index < 4) {
          options[index] = match[2].trim().replace(/\.$/, ''); // B·ªè d·∫•u ch·∫•m cu·ªëi
        }
      }
    });
    
    return options;
  }, []);

  // Extract question content (remove number prefix)
  const parseQuestion = useCallback((questionString: string): string => {
    if (!questionString || typeof questionString !== 'string') return '';
    
    // Remove number prefix like "C√¢u 81: " 
    return questionString.replace(/^C√¢u \d+:\s*/, '').trim();
  }, []);

  // Extract correct answer from answers string
  const parseCorrectAnswer = useCallback((answersString: string): string => {
    if (!answersString || typeof answersString !== 'string') return '';
    
    // KH√îNG t·ª± ƒë·ªông parse ƒë√°p √°n ƒë√∫ng t·ª´ chu·ªói options
    // Ch·ªâ tr·∫£ v·ªÅ ƒë√°p √°n ƒë√∫ng n·∫øu c√≥ th√¥ng tin r√µ r√†ng t·ª´ API/data kh√°c
    // Hi·ªán t·∫°i tr·∫£ v·ªÅ r·ªóng ƒë·ªÉ kh√¥ng t·ª± ƒë·ªông ch·ªçn ƒë√°p √°n n√†o
    return '';
  }, []);

  // Parse full question to get both question and options for display
  const parseQuestionForDisplay = useCallback((questionString: string, answersString: string) => {
    const questionContent = parseQuestion(questionString);
    const options = parseAnswers(answersString);
    const correctAnswer = parseCorrectAnswer(answersString);
    
    return { questionContent, options, correctAnswer };
  }, [parseQuestion, parseAnswers, parseCorrectAnswer]);

  // Convert uploaded data to form format
  const convertToFormData = useCallback(() => {
    const questionsToUse = selectedQuestions.length > 0 
      ? safeData.filter((_, index) => selectedQuestions.includes(index))
      : safeData;

    return questionsToUse.map(item => {
      const answers = parseAnswers(item.answers);
      const question = parseQuestion(item.question);
      const correctAnswer = parseCorrectAnswer(item.answers);
      
      return {
        content: question,
        options: answers, // M·∫£ng 4 ƒë√°p √°n ƒë√£ ƒë∆∞·ª£c parse
        correctAnswer: correctAnswer || undefined, // Ch·ªâ set n·∫øu c√≥ gi√° tr·ªã, n·∫øu kh√¥ng th√¨ undefined
        explanation: '',
        difficulty: 1,
        isActive: true
      };
    });
  }, [safeData, selectedQuestions, parseAnswers, parseQuestion, parseCorrectAnswer]);

  const handleConfirm = () => {
    const formattedData = convertToFormData();
    onConfirm(formattedData);
    onClose();
  };

  const handleSelectQuestion = (index: number) => {
    setSelectedQuestions(prev => {
      if (prev.includes(index)) {
        return prev.filter(i => i !== index);
      } else {
        return [...prev, index];
      }
    });
  };

  const selectAllQuestions = () => {
    if (selectedQuestions.length === safeData.length) {
      setSelectedQuestions([]);
    } else {
      setSelectedQuestions(safeData.map((_, index) => index));
    }
  };

  const renderQuestion = (item: UploadedQuestion, index: number) => {
    const { questionContent, options, correctAnswer } = parseQuestionForDisplay(item.question, item.answers);
    const isSelected = selectedQuestions.includes(index);

    return (
      <Card
        key={index}
        size="small"
        className={`question-card ${isSelected ? 'selected' : ''}`}
        style={{
          marginBottom: 12,
          border: isSelected ? '2px solid #1890ff' : '1px solid #d9d9d9',
          cursor: 'pointer'
        }}
        onClick={() => handleSelectQuestion(index)}
        hoverable
      >
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
          <div style={{ flex: 1 }}>
            <Title level={5} style={{ marginBottom: 8, color: '#1890ff' }}>
              C√¢u {index + 1}
              {isSelected && <CheckCircleOutlined style={{ color: '#52c41a', marginLeft: 8 }} />}
            </Title>
            <Paragraph style={{ marginBottom: 12 }}>
              <Text strong>C√¢u h·ªèi:</Text>
              <br />
              <span dangerouslySetInnerHTML={{ __html: questionContent }} />
            </Paragraph>
            
            {/* Hi·ªÉn th·ªã c√°c l·ª±a ch·ªçn */}
            <div style={{ marginBottom: 12 }}>
              <Text strong>C√°c l·ª±a ch·ªçn:</Text>
              {options.map((option, optIndex) => {
                if (!option.trim()) return null;
                const letter = String.fromCharCode(65 + optIndex); // A, B, C, D
                const isCorrect = correctAnswer && correctAnswer === letter; // Ch·ªâ highlight khi c√≥ correctAnswer
                return (
                  <div 
                    key={optIndex} 
                    style={{ 
                      marginLeft: 16,
                      padding: '4px 8px',
                      backgroundColor: isCorrect ? '#f6ffed' : 'transparent',
                      border: isCorrect ? '1px solid #52c41a' : 'none',
                      borderRadius: 4,
                      marginTop: 4
                    }}
                  >
                    <Text strong={!!isCorrect}>
                      {letter}. {option}
                    </Text>
                  </div>
                );
              })}
            </div>
            
            {/* Ch·ªâ hi·ªÉn th·ªã ƒë√°p √°n ƒë√∫ng khi th·ª±c s·ª± c√≥ */}
            {correctAnswer && (
              <div>
                <Text strong>ƒê√°p √°n ƒë√∫ng:</Text>
                <div style={{ paddingLeft: 16, marginTop: 4 }}>
                  <Text 
                    style={{ 
                      backgroundColor: '#f6ffed', 
                      color: '#389e0d', 
                      padding: '2px 8px', 
                      borderRadius: 4,
                      fontWeight: 'bold'
                    }}
                  >
                    {correctAnswer}
                  </Text>
                </div>
              </div>
            )}
          </div>
        </div>
      </Card>
    );
  };

  // Early return n·∫øu kh√¥ng c√≥ d·ªØ li·ªáu
  if (!safeData.length) {
    return (
      <Modal
        title="Kh√¥ng c√≥ d·ªØ li·ªáu"
        open={visible}
        onCancel={onClose}
        footer={[
          <Button key="close" onClick={onClose}>
            ƒê√≥ng
          </Button>
        ]}
      >
        <p>Kh√¥ng c√≥ c√¢u h·ªèi n√†o ƒë·ªÉ hi·ªÉn th·ªã.</p>
      </Modal>
    );
  }

  return (
    <Modal
      title={
        <Space>
          <EyeOutlined />
          <span>Xem tr∆∞·ªõc d·ªØ li·ªáu Upload ({safeData.length} c√¢u h·ªèi)</span>
        </Space>
      }
      open={visible}
      onCancel={onClose}
      width="80%"
      style={{ top: 20 }}
      bodyStyle={{ maxHeight: '70vh', overflow: 'auto' }}
      footer={[
        <Button key="cancel" onClick={onClose}>
          H·ªßy
        </Button>,
        <Button 
          key="selectAll" 
          onClick={selectAllQuestions}
          type={selectedQuestions.length === safeData.length ? "default" : "dashed"}
        >
          {selectedQuestions.length === safeData.length ? 'B·ªè ch·ªçn t·∫•t c·∫£' : 'Ch·ªçn t·∫•t c·∫£'}
        </Button>,
        <Button 
          key="confirm" 
          type="primary" 
          icon={<EditOutlined />}
          onClick={handleConfirm}
          disabled={selectedQuestions.length === 0 && safeData.length > 0}
        >
          T·∫°o ƒë·ªÅ thi v·ªõi {selectedQuestions.length || safeData.length} c√¢u h·ªèi
        </Button>,
      ]}
    >
      <div style={{ marginBottom: 16 }}>
        <div style={{ 
          padding: '12px 16px', 
          backgroundColor: '#f6ffed', 
          border: '1px solid #b7eb8f',
          borderRadius: 6,
          marginBottom: 16 
        }}>
          <Title level={5} style={{ margin: 0, color: '#389e0d' }}>
            üìã H∆∞·ªõng d·∫´n
          </Title>
          <ul style={{ margin: '8px 0 0 0', paddingLeft: 20, color: '#666' }}>
            <li>Click v√†o c√¢u h·ªèi ƒë·ªÉ ch·ªçn/b·ªè ch·ªçn</li>
            <li>C√¢u h·ªèi ƒë∆∞·ª£c ch·ªçn s·∫Ω c√≥ vi·ªÅn xanh v√† bi·ªÉu t∆∞·ª£ng ‚úì</li>
            <li>B·∫°n c√≥ th·ªÉ ch·ªçn t·∫•t c·∫£ ho·∫∑c ch·ªâ m·ªôt s·ªë c√¢u h·ªèi</li>
            <li>ƒê√°p √°n ƒë√∫ng ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông ph√°t hi·ªán</li>
            <li>B·∫°n s·∫Ω c·∫ßn nh·∫≠p c√°c l·ª±a ch·ªçn A, B, C, D trong form t·∫°o ƒë·ªÅ thi</li>
            <li>Sau khi x√°c nh·∫≠n, form t·∫°o ƒë·ªÅ thi s·∫Ω ƒë∆∞·ª£c fill s·∫µn d·ªØ li·ªáu</li>
          </ul>
        </div>

        <div style={{ 
          display: 'flex', 
          justifyContent: 'space-between', 
          alignItems: 'center',
          marginBottom: 16,
          padding: '8px 12px',
          backgroundColor: '#fafafa',
          borderRadius: 4
        }}>
          <Text strong>
            ƒê√£ ch·ªçn: {selectedQuestions.length}/{safeData.length} c√¢u h·ªèi
          </Text>
          <Button size="small" type="link" onClick={selectAllQuestions}>
            {selectedQuestions.length === safeData.length ? 'B·ªè ch·ªçn t·∫•t c·∫£' : 'Ch·ªçn t·∫•t c·∫£'}
          </Button>
        </div>
      </div>

      <div>
        {safeData.map((item, index) => renderQuestion(item, index))}
      </div>
    </Modal>
  );
};

export default UploadPreviewModal;